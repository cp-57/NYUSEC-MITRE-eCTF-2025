import argparse
import struct
import json
import os
from Crypto.Cipher import ChaCha20_Poly1305
# uses ECB mode

class Encoder:
    def __init__(self, secrets: bytes):
        """
        You **may not** change the arguments or returns of this function!

        :param secrets: Contents of the secrets file generated by
            ectf25_design.gen_secrets
        """
        try:
            # Load the JSON of the secrets file
            secrets = json.loads(secrets)
        except json.JSONDecodeError:
            raise ValueError("Invalid secrets file format")

        self.chacha_key = bytes.fromhex(secrets["chacha_key"]).ljust(32, b'\0') 
        self.channel_keys = {
            int(ch): bytes.fromhex(key).ljust(32, b'\0')
            for ch, key in secrets["channel_keys"].items()
        }

    def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
        """The frame encoder function

        This will be called for every frame that needs to be encoded before being
        transmitted by the satellite to all listening TVs.

        You **may not** change the arguments or returns of this function!

        :param channel: 16b unsigned channel number. Channel 0 is the emergency
            broadcast that must be decodable by all channels.
        :param frame: Frame to encode. Max frame size is 64 bytes.
        :param timestamp: 64b timestamp to use for encoding.

        :returns: The encoded frame, which will be sent to the Decoder.
        """
        if len(frame) > 64:
            raise ValueError("Frame size exceeds 64 bytes")

        channel_key = self.channel_keys.get(channel, self.channel_keys[0])
        cipher = ChaCha20_Poly1305.new(key=channel_key)
        header = struct.pack("<IQ", channel, timestamp)

        cipher.update(header)

        ciphertext, tag = cipher.encrypt_and_digest(frame)

        return header + cipher.nonce + ciphertext + tag


def main():
    """A test main to one-shot encode a frame

    This function is only for your convenience and will not be used in the final design.

    After installing pycryptodome, you should be able to call this with:
        python3 -m ectf25_design.encoder path/to/test.secrets 1 "frame to encode" 100
    """
    parser = argparse.ArgumentParser(prog="ectf25_design.encoder")
    parser.add_argument(
        "secrets_file", type=argparse.FileType("rb"), help="Path to the secrets file"
    )
    parser.add_argument("channel", type=int, help="Channel to encode for")
    parser.add_argument("frame", help="Contents of the frame")
    parser.add_argument("timestamp", type=int, help="64b timestamp to use")
    args = parser.parse_args()

    encoder = Encoder(args.secrets_file.read())
    print(repr(encoder.encode(args.channel, args.frame.encode(), args.timestamp)))


if __name__ == "__main__":
    main()